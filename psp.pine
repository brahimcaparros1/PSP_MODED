// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=6
indicator('QT Insights [Pro +]: PSP / PC [cephxs]', 'PSP [Pro +] | cephxs', overlay = true)

// ==================== PSP SETTINGS ====================
// Pair Configuration
g_pair1 = "Pair 1 Configuration"
asset1_pair1_input = input.symbol("ES1!", "Asset 1", group=g_pair1)
asset2_pair1_input = input.symbol("NQ1!", "Asset 2", group=g_pair1)

g_pair2 = "Pair 2 Configuration"
asset1_pair2_input = input.symbol("EURUSD", "Asset 1", group=g_pair2)
asset2_pair2_input = input.symbol("GBPUSD", "Asset 2", group=g_pair2)

g_pair3 = "Pair 3 Configuration"
asset1_pair3_input = input.symbol("6E1!", "Asset 1", group=g_pair3)
asset2_pair3_input = input.symbol("6B1!", "Asset 2", group=g_pair3)

g_pair4 = "Pair 4 Configuration"
asset1_pair4_input = input.symbol("BINANCE:BTCUSDT.P", "Asset 1", group=g_pair4)
asset2_pair4_input = input.symbol("BINANCE:ETHUSDT.P", "Asset 2", group=g_pair4)

// Display Settings
g_displaySettings = "Display Settings"
mode = input.string('All precision candles', 'Mode', options = ['PSP only', 'All precision candles'], group = g_displaySettings, tooltip = 'Select the mode for highlighting candles. \'All precision candles\' highlights all divergence candles, while \'PSP only\' highlights only Precision Swing Points with divergence.')
showDebug = input.bool(false, 'Show Debug Info', group = g_displaySettings, tooltip = 'Show debug information about current symbol and active pair')

// Open Divergence Settings
g_openDivergence = "Open Divergence Lines"
showOpenDivergence = input.bool(true, 'Show Open Divergence Lines', group = g_openDivergence, tooltip = 'Draw lines when opens show divergence trend between assets')
openDivergenceMode = input.string('Latest Only', 'Line Display Mode', options = ['All Lines', 'Latest Only'], group = g_openDivergence, tooltip = 'All Lines: Keep all divergence lines | Latest Only: Keep only the most recent lines')
maxLines = input.int(5, 'Max Lines (Latest Only)', minval = 1, maxval = 20, group = g_openDivergence, tooltip = 'Maximum number of lines to display in Latest Only mode')

// Divergence Display Settings
g_divergenceSettings = "Divergence Display Settings"
enableDivergences = input.bool(true, 'Enable Divergences', group = g_divergenceSettings, tooltip = 'Shows divergences on supported timeframes: W, D, H4, H1, M15, M5, M1')

// Timeframe visibility controls (tickboxes per base timeframe)
g_visibilityNormal = "Normal Divergence Visibility"
normalShow1W = input.bool(true, 'Show Normal on 1W', group = g_visibilityNormal)
normalShow1D = input.bool(true, 'Show Normal on 1D', group = g_visibilityNormal)
normalShow240 = input.bool(true, 'Show Normal on 4H', group = g_visibilityNormal)
normalShow60 = input.bool(true, 'Show Normal on 1H', group = g_visibilityNormal)
normalShow15 = input.bool(true, 'Show Normal on 15m', group = g_visibilityNormal)
normalShow5 = input.bool(true, 'Show Normal on 5m', group = g_visibilityNormal)
normalShow1 = input.bool(true, 'Show Normal on 1m', group = g_visibilityNormal)

g_visibilityHTF = "HTF Divergence Visibility"
htfShow1W = input.bool(true, 'Show HTF on 1W', group = g_visibilityHTF)
htfShow1D = input.bool(true, 'Show HTF on 1D', group = g_visibilityHTF)
htfShow240 = input.bool(true, 'Show HTF on 4H', group = g_visibilityHTF)
htfShow60 = input.bool(true, 'Show HTF on 1H', group = g_visibilityHTF)
htfShow15 = input.bool(true, 'Show HTF on 15m', group = g_visibilityHTF)
htfShow5 = input.bool(true, 'Show HTF on 5m', group = g_visibilityHTF)
htfShow1 = input.bool(true, 'Show HTF on 1m', group = g_visibilityHTF)

// HTF source mapping (customisable higher timeframe for each base timeframe)
g_htfSources = "HTF Source Mapping"
htfSource1W = input.timeframe('1M', '1W HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 1W charts')
htfSource1D = input.timeframe('1W', '1D HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 1D charts')
htfSource240 = input.timeframe('W', '4H HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 4H charts')
htfSource60 = input.timeframe('D', '1H HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 1H charts')
htfSource15 = input.timeframe('240', '15m HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 15m charts')
htfSource5 = input.timeframe('60', '5m HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 5m charts')
htfSource1 = input.timeframe('15', '1m HTF Source', group = g_htfSources, tooltip = 'Higher timeframe used when displaying HTF divergences while on 1m charts')

// Color customisation (color boxes)
g_colorSettings = "Color Settings"
bullishLineColor = input.color(color.green, 'Bullish Line', group = g_colorSettings)
bearishLineColor = input.color(color.red, 'Bearish Line', group = g_colorSettings)
neutralLineColor = input.color(color.white, 'Neutral Line', group = g_colorSettings)
bullishBarColor = input.color(color.green, 'Bullish Bar', group = g_colorSettings)
bearishBarColor = input.color(color.red, 'Bearish Bar', group = g_colorSettings)
bullishShapeColor = input.color(color.green, 'Bullish Label/Shape', group = g_colorSettings)
bearishShapeColor = input.color(color.red, 'Bearish Label/Shape', group = g_colorSettings)
neutralLabelColor = input.color(color.new(color.white, 0), 'Neutral Label', group = g_colorSettings)

// Label controls
g_labelSettings = "Label Settings"
showDivergenceLabels = input.bool(false, 'Show Divergence Labels', group = g_labelSettings, tooltip = 'When enabled, labels are added near divergence candles. Disable to hide all divergence labels.')

// ==================== PSP FUNCTIONS ====================
// Function to extract symbol without exchange prefix
extractSymbol(fullSymbol) =>
    if str.contains(fullSymbol, ":")
        // Split at colon and take the part after it
        parts = str.split(fullSymbol, ":")
        array.size(parts) > 1 ? array.get(parts, 1) : fullSymbol
    else
        fullSymbol

// HTF positioning now uses xloc.bar_time for perfect temporal alignment

// Get the current chart symbol and check if it's part of any configured pair
currentSymbol = syminfo.ticker

// Extract clean symbols from inputs
asset1_pair1_clean = extractSymbol(asset1_pair1_input)
asset2_pair1_clean = extractSymbol(asset2_pair1_input)
asset1_pair2_clean = extractSymbol(asset1_pair2_input)
asset2_pair2_clean = extractSymbol(asset2_pair2_input)
asset1_pair3_clean = extractSymbol(asset1_pair3_input)
asset2_pair3_clean = extractSymbol(asset2_pair3_input)
asset1_pair4_clean = extractSymbol(asset1_pair4_input)
asset2_pair4_clean = extractSymbol(asset2_pair4_input)

// Check which pair the current symbol belongs to (if any)
isAsset1_Pair1 = currentSymbol == asset1_pair1_clean
isAsset2_Pair1 = currentSymbol == asset2_pair1_clean
isAsset1_Pair2 = currentSymbol == asset1_pair2_clean
isAsset2_Pair2 = currentSymbol == asset2_pair2_clean
isAsset1_Pair3 = currentSymbol == asset1_pair3_clean
isAsset2_Pair3 = currentSymbol == asset2_pair3_clean
isAsset1_Pair4 = currentSymbol == asset1_pair4_clean
isAsset2_Pair4 = currentSymbol == asset2_pair4_clean

// Determine which pair the current symbol belongs to
belongsToPair1 = isAsset1_Pair1 or isAsset2_Pair1
belongsToPair2 = isAsset1_Pair2 or isAsset2_Pair2
belongsToPair3 = isAsset1_Pair3 or isAsset2_Pair3
belongsToPair4 = isAsset1_Pair4 or isAsset2_Pair4
belongsToAnyPair = belongsToPair1 or belongsToPair2 or belongsToPair3 or belongsToPair4

// OPTIMIZED: Debug labels (only update when needed)
var label debugLabel = na
if showDebug and barstate.islast
    pairInfo = ""
    if belongsToPair1
        pairInfo := "Pair1: " + asset1_pair1_clean + "/" + asset2_pair1_clean
    else if belongsToPair2  
        pairInfo := "Pair2: " + asset1_pair2_clean + "/" + asset2_pair2_clean
    else if belongsToPair3
        pairInfo := "Pair3: " + asset1_pair3_clean + "/" + asset2_pair3_clean
    else if belongsToPair4
        pairInfo := "Pair4: " + asset1_pair4_clean + "/" + asset2_pair4_clean
    else
        pairInfo := "No pair found"

    debugText = "Current: " + currentSymbol + " | " + pairInfo
    if na(debugLabel)
        debugLabel := label.new(bar_index, high, debugText, style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
    else
        label.set_text(debugLabel, debugText)
        label.set_xy(debugLabel, bar_index, high)
else if not showDebug and not na(debugLabel)
    // Remove debug label if debug is disabled
    label.delete(debugLabel)
    debugLabel := na

// OPTIMIZED: Warning label (only update when needed)
var label infoLabel = na
if not belongsToAnyPair and barstate.islast
    if na(infoLabel)
        infoLabel := label.new(bar_index, high + ta.tr, "Symbol not part of configured pairs", 
                              style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)
    else
        label.set_xy(infoLabel, bar_index, high + ta.tr)

// Determine which assets to fetch data for based on current symbol
asset1 = if belongsToPair1
    asset1_pair1_input
else if belongsToPair2
    asset1_pair2_input
else if belongsToPair3
    asset1_pair3_input
else if belongsToPair4
    asset1_pair4_input
else
    na

asset2 = if belongsToPair1
    asset2_pair1_input
else if belongsToPair2
    asset2_pair2_input
else if belongsToPair3
    asset2_pair3_input
else if belongsToPair4
    asset2_pair4_input
else
    na

// Array to store divergence lines for Latest Only mode
var array<line> divergenceLines = array.new<line>()
var array<label> divergenceLabels = array.new<label>()

// REFACTORED: Fixed timeframe logic - only 7 specific timeframes supported
// Check if current timeframe is supported
currentTF = timeframe.period
isBaseTF = currentTF == "1W" or currentTF == "1D" or currentTF == "240" or currentTF == "60" or currentTF == "15" or currentTF == "5" or currentTF == "1"

// DO NOT MODIFY belongsToAnyPair! It's needed for data fetching
// Create a separate variable for display control
canDisplay = isBaseTF and enableDivergences and belongsToAnyPair

// Determine per-timeframe visibility from tickboxes
normalEnabled = switch currentTF
    "1W" => normalShow1W
    "1D" => normalShow1D
    "240" => normalShow240
    "60" => normalShow60
    "15" => normalShow15
    "5" => normalShow5
    "1" => normalShow1
    => false

htfEnabled = switch currentTF
    "1W" => htfShow1W
    "1D" => htfShow1D
    "240" => htfShow240
    "60" => htfShow60
    "15" => htfShow15
    "5" => htfShow5
    "1" => htfShow1
    => false

htfToUse = switch currentTF
    "1W" => htfSource1W
    "1D" => htfSource1D
    "240" => htfSource240
    "60" => htfSource60
    "15" => htfSource15
    "5" => htfSource5
    "1" => htfSource1
    => ""

processNormal = normalEnabled and canDisplay
processHTF = htfEnabled and canDisplay and str.length(htfToUse) > 0

// OPTIMIZED: Fetch data for the relevant pair only
asset1_open = belongsToAnyPair ? request.security(asset1, timeframe.period, open) : na
asset1_close = belongsToAnyPair ? request.security(asset1, timeframe.period, close) : na
asset1_close_before = belongsToAnyPair ? request.security(asset1, timeframe.period, close[2]) : na

asset2_open = belongsToAnyPair ? request.security(asset2, timeframe.period, open) : na
asset2_close = belongsToAnyPair ? request.security(asset2, timeframe.period, close) : na
asset2_close_before = belongsToAnyPair ? request.security(asset2, timeframe.period, close[2]) : na

// OPTIMIZED: Only calculate normal divergence when needed (not on M5/M1)
bullish1 = false
bearish1 = false
bullish2 = false
bearish2 = false
divergence = false

if processNormal
    bullish1 := belongsToAnyPair and asset1_close > asset1_open
    bearish1 := belongsToAnyPair and asset1_close < asset1_open
    bullish2 := belongsToAnyPair and asset2_close > asset2_open
    bearish2 := belongsToAnyPair and asset2_close < asset2_open
    // Calculate divergence for current pair
    divergence := belongsToAnyPair and ((bullish1 and bearish2) or (bearish1 and bullish2))

// Overall highlight condition (current bar) - for colorization on ALL supported timeframes
current_highlight = canDisplay and barstate.isconfirmed and divergence

// Check if previous candle had divergence
had_divergence_prev = current_highlight[1]

// Set highlight for display
highlight = current_highlight

// Determine if current symbol is asset1 or asset2 of the active pair
isCurrentAsset1 = isAsset1_Pair1 or isAsset1_Pair2 or isAsset1_Pair3 or isAsset1_Pair4

// Check if previous candle should have divergence lines: now only requires divergence on [1], no swing requirement
should_draw_divergence_line = had_divergence_prev

// Calculate open trend divergence between candles surrounding the divergent one
open_divergence_exists = false
open_divergence_bullish = false
open_divergence_bearish = false

line_drawn_now = false

if processNormal and showOpenDivergence and should_draw_divergence_line
    // Trend from before divergence to after (current)
    // Asset 1 trend: from close[2] to open[0]
    asset1_trend_up = asset1_open > asset1_close_before
    asset1_trend_down = asset1_open < asset1_close_before
    
    // Asset 2 trend: from close[2] to open[0]
    asset2_trend_up = asset2_open > asset2_close_before
    asset2_trend_down = asset2_open < asset2_close_before
    
    // Divergence: opposite trends
    open_divergence_bullish := asset1_trend_up and asset2_trend_down
    open_divergence_bearish := asset1_trend_down and asset2_trend_up
    open_divergence_exists := open_divergence_bullish or open_divergence_bearish

// Draw lines between opens surrounding the divergent candle
if should_draw_divergence_line and open_divergence_exists and barstate.isconfirmed and showOpenDivergence
    // Line color based on HH/LL of the colored candle [1] vs previous [2]
    localLL = low[1] < low[2]
    localHH = high[1] > high[2]
    insideBar = high[1] <= high[2] and low[1] >= low[2]
    // New white-line conditions with tick tolerance:
    // - Equal High OR Equal Low with previous candle (within 1 tick),
    //   but only if the opposite extreme is NOT broken.
    // - Both LL and HH (outside bar / engulfing) → white
    eqTol = syminfo.mintick
    eqHigh = math.abs(high[1] - high[2]) <= eqTol
    eqLow  = math.abs(low[1]  - low[2])  <= eqTol
    outsideBar = localHH and localLL
    whiteCond = insideBar or outsideBar or (eqHigh and not localLL) or (eqLow and not localHH)
    lineColor = whiteCond ? neutralLineColor : localHH and not localLL ? bearishLineColor : localLL and not localHH ? bullishLineColor : bearishLineColor
    
    // Line connects close[2] to open[0], spanning over divergent candle[1]
    // Use LOCAL values of the currently displayed asset (not asset1/asset2 selection)
    prevPoint = close[2]   // Local close 2 bars ago of current asset
    openCurrent = open     // Local current open of current asset
    divergenceLine = line.new(x1 = bar_index[2], y1 = prevPoint, x2 = bar_index, y2 = openCurrent, color = lineColor, width = 2, style = line.style_solid)
    label divergenceLabel = na
    if showDivergenceLabels
        labelText = open_divergence_bullish ? 'Bull Div' : open_divergence_bearish ? 'Bear Div' : 'Div'
        labelColor = open_divergence_bullish ? bullishShapeColor : open_divergence_bearish ? bearishShapeColor : neutralLabelColor
        labelPrice = (prevPoint + openCurrent) / 2.0
        divergenceLabel := label.new(bar_index[1], labelPrice, labelText, 
                                     xloc = xloc.bar_index, 
                                     style = label.style_label_center, 
                                     color = color.new(labelColor, 70), 
                                     textcolor = color.white, 
                                     size = size.tiny)
    
    // Manage lines based on display mode
    if openDivergenceMode == 'Latest Only'
        array.push(divergenceLines, divergenceLine)
        array.push(divergenceLabels, divergenceLabel)
        if array.size(divergenceLines) > maxLines
            oldLine = array.shift(divergenceLines)
            line.delete(oldLine)
            oldLabel = array.shift(divergenceLabels)
            if not na(oldLabel)
                label.delete(oldLabel)
    // If 'All Lines' mode, just leave the line (no management needed)
    else
        array.push(divergenceLines, divergenceLine)
        array.push(divergenceLabels, divergenceLabel)

    line_drawn_now := true

// ==================== HTF DIVERGENCE LOGIC ====================
// HTF Divergence calculation and line drawing - COMPLETELY REFACTORED
// Track if an HTF line is drawn on this bar (for coloring gate)
htf_line_drawn_now = false
if processHTF
    // Detect new HTF bar
    htf_new_bar = ta.change(time(htfToUse)) != 0
    
    // Get HTF asset data
    [htf_asset1_close, htf_asset1_open] = request.security(asset1, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close, htf_asset2_open] = request.security(asset2, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset1_close_prev, htf_asset1_open_prev] = request.security(asset1, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close_prev, htf_asset2_open_prev] = request.security(asset2, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    
    // Calculate HTF bullish/bearish for current and previous bars
    htf_bullish1 = htf_asset1_close > htf_asset1_open
    htf_bearish1 = htf_asset1_close < htf_asset1_open
    htf_bullish2 = htf_asset2_close > htf_asset2_open
    htf_bearish2 = htf_asset2_close < htf_asset2_open
    
    htf_bullish1_prev = htf_asset1_close_prev > htf_asset1_open_prev
    htf_bearish1_prev = htf_asset1_close_prev < htf_asset1_open_prev
    htf_bullish2_prev = htf_asset2_close_prev > htf_asset2_open_prev
    htf_bearish2_prev = htf_asset2_close_prev < htf_asset2_open_prev
    
    // Calculate HTF divergences
    htf_divergence_current = (htf_bullish1 and htf_bearish2) or (htf_bearish1 and htf_bullish2)
    htf_divergence_prev = (htf_bullish1_prev and htf_bearish2_prev) or (htf_bearish1_prev and htf_bullish2_prev)
    
    // Determine if we should draw HTF divergence line: now only requires HTF divergence on [1], no swing requirement
    htf_should_draw = htf_divergence_prev
    
    // Calculate HTF open trend divergence if we should draw
    if htf_should_draw and showOpenDivergence and htf_new_bar
        // Get HTF points for trend comparison (close[2] to open[0] on HTF)
        [htf_asset1_close_2bars, htf_asset1_open_current] = request.security(asset1, htfToUse, [close[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_asset2_close_2bars, htf_asset2_open_current] = request.security(asset2, htfToUse, [close[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        
        // HTF Asset trends: from close[2] to open[0] on HTF
        htf_asset1_trend_up = htf_asset1_open_current > htf_asset1_close_2bars
        htf_asset1_trend_down = htf_asset1_open_current < htf_asset1_close_2bars
        htf_asset2_trend_up = htf_asset2_open_current > htf_asset2_close_2bars
        htf_asset2_trend_down = htf_asset2_open_current < htf_asset2_close_2bars
        
        // HTF Open divergence: opposite trends
        htf_open_divergence_bullish = htf_asset1_trend_up and htf_asset2_trend_down
        htf_open_divergence_bearish = htf_asset1_trend_down and htf_asset2_trend_up
        htf_open_divergence_exists = htf_open_divergence_bullish or htf_open_divergence_bearish
        
        if htf_open_divergence_exists
            // HTF line color based on HH/LL of HTF colored candle [1] vs previous [2]
            [htf_low1, htf_low2, htf_high1, htf_high2] = request.security(syminfo.tickerid, htfToUse, [low[1], low[2], high[1], high[2]], barmerge.gaps_off, barmerge.lookahead_on)
            htfLL = htf_low1 < htf_low2
            htfHH = htf_high1 > htf_high2
            htf_insideBar = htf_high1 <= htf_high2 and htf_low1 >= htf_low2
            htf_color = htf_insideBar ? neutralLineColor : htfHH and not htfLL ? bearishLineColor : htfLL and not htfHH ? bullishLineColor : bearishLineColor
            
            // Get HTF values and timestamps
            [htf_time_start_1, htf_time_current] = request.security(syminfo.tickerid, htfToUse, [time[1], time], barmerge.gaps_off, barmerge.lookahead_on)
            
            // Find the last bar of the current timeframe that belongs to HTF[2]
            // HTF[1] starts at htf_time_start_1, so we need the bar just before that
            x1_bar_index = bar_index
            bars_back = 0
            for i = 0 to 500  // Look back up to 500 bars
                if time[i] < htf_time_start_1
                    // Found a bar that's before HTF[1], so it belongs to HTF[2] or earlier
                    x1_bar_index := bar_index - i
                    bars_back := i
                    break
            
            // Get the close value from the LOCAL bar at x1_bar_index (last bar of HTF[2])
            htf_prevPoint = close[bars_back]
            
            // Get current open value for endpoint
            htf_openCurrent = open
            
            x2_bar_index = bar_index
            
            // Draw HTF line using bar indices for accurate positioning  
            htf_divergenceLine = line.new(x1 = x1_bar_index, y1 = htf_prevPoint, x2 = x2_bar_index, y2 = htf_openCurrent, xloc = xloc.bar_index, color = htf_color, width = 2, style = line.style_solid)
            label htf_divergenceLabel = na
            if showDivergenceLabels
                labelText = htf_open_divergence_bullish ? 'HTF Bull Div' : htf_open_divergence_bearish ? 'HTF Bear Div' : 'HTF Div'
                labelColor = htf_open_divergence_bullish ? bullishShapeColor : htf_open_divergence_bearish ? bearishShapeColor : neutralLabelColor
                labelPrice = (htf_prevPoint + htf_openCurrent) / 2.0
                htf_divergenceLabel := label.new(bar_index, labelPrice, labelText, 
                                                 xloc = xloc.bar_index, 
                                                 style = label.style_label_center, 
                                                 color = color.new(labelColor, 70), 
                                                 textcolor = color.white, 
                                                 size = size.tiny)
            
            // Manage HTF lines (same system as normal lines)
            if openDivergenceMode == 'Latest Only'
                array.push(divergenceLines, htf_divergenceLine)
                array.push(divergenceLabels, htf_divergenceLabel)
                if array.size(divergenceLines) > maxLines
                    oldLine = array.shift(divergenceLines)
                    line.delete(oldLine)
                    oldLabel = array.shift(divergenceLabels)
                    if not na(oldLabel)
                        label.delete(oldLabel)
            // If 'All Lines' mode, just leave the line
            else
                array.push(divergenceLines, htf_divergenceLine)
                array.push(divergenceLabels, htf_divergenceLabel)
            // Mark that an HTF line was drawn on this bar
            htf_line_drawn_now := true

// Determine overall bullish/bearish ONLY for normal divergences, NOT HTF
overallBullish = processNormal and (isCurrentAsset1 ? bullish1 : bullish2)
overallBearish = processNormal and (isCurrentAsset1 ? bearish1 : bearish2)

// Detect PSP condition without 3-candle swing requirement
lineTriggered = line_drawn_now or htf_line_drawn_now
divergenceDetected = highlight[1] or lineTriggered
isPsp = if mode == 'PSP only'
    divergenceDetected and lineTriggered
else
    divergenceDetected

// ==================== EXECUTE PSP LOGIC
// Set bar color based on display mode
// On M5 and M1 (HTF-only), do NOT color bars
var color barColor = na
any_line_drawn = lineTriggered
if processNormal
    if mode == 'All precision candles'
        // Color ONLY if a line was drawn (divergence + open divergence)
        barColor := any_line_drawn ? (overallBullish[1] ? bullishBarColor : bearishBarColor) : na
    else if mode == 'PSP only'
        // Color like the other mode: only requires a line was drawn (no swing requirement)
        barColor := any_line_drawn ? (overallBullish[1] ? bullishBarColor : bearishBarColor) : na
else
    barColor := na

barcolor(barColor, offset = -1)// Apply bar color

// Plot shapes for 'All precision candles' mode - ONLY when line is drawn
plotshape(mode == 'All precision candles' and any_line_drawn and overallBullish[1], 
          style = shape.circle, 
          location = location.belowbar, 
          color = bullishShapeColor, 
          size = size.auto, 
          offset = -1,
          title = 'Bullish PC',
          display = display.none)

plotshape(mode == 'All precision candles' and any_line_drawn and overallBearish[1], 
          style = shape.circle, 
          location = location.abovebar, 
          color = bearishShapeColor, 
          size = size.auto, 
          offset = -1,
          title = 'Bearish PC',
          display = display.none)

// Plot shapes for 'PSP only' mode - ONLY when PSP AND line is drawn
plotshape(mode == 'PSP only' and isPsp and any_line_drawn and overallBullish[1], 
          style = shape.circle, 
          location = location.belowbar, 
          color = bullishShapeColor, 
          size = size.auto, 
          offset = -1, 
          title = 'Bullish PSP',
          display = display.none)

plotshape(mode == 'PSP only' and isPsp and any_line_drawn and overallBearish[1], 
          style = shape.circle, 
          location = location.abovebar, 
          color = bearishShapeColor, 
          size = size.auto, 
          offset = -1, 
          title = 'Bearish PSP',
          display = display.none)

// Clean up lines when open divergence feature is disabled
if not showOpenDivergence and array.size(divergenceLines) > 0
    for i = 0 to array.size(divergenceLines) - 1
        line.delete(array.get(divergenceLines, i))
    array.clear(divergenceLines)
    for i = 0 to array.size(divergenceLabels) - 1
        existingLabel = array.get(divergenceLabels, i)
        if not na(existingLabel)
            label.delete(existingLabel)
    array.clear(divergenceLabels)
else if not showDivergenceLabels and array.size(divergenceLabels) > 0
    for i = 0 to array.size(divergenceLabels) - 1
        existingLabel = array.get(divergenceLabels, i)
        if not na(existingLabel)
            label.delete(existingLabel)
        array.set(divergenceLabels, i, na)
