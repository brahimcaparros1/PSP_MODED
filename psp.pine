// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=6
indicator('QT Insights [Pro +]: PSP / PC [cephxs]', 'PSP [Pro +] | cephxs', overlay = true)

// ==================== PSP SETTINGS ====================
// Pair Configuration
g_pair1 = "Pair 1 Configuration"
asset1_pair1_input = input.symbol("ES1!", "Asset 1", group=g_pair1)
asset2_pair1_input = input.symbol("NQ1!", "Asset 2", group=g_pair1)

g_pair2 = "Pair 2 Configuration"
asset1_pair2_input = input.symbol("EURUSD", "Asset 1", group=g_pair2)
asset2_pair2_input = input.symbol("GBPUSD", "Asset 2", group=g_pair2)

g_pair3 = "Pair 3 Configuration"
asset1_pair3_input = input.symbol("6E1!", "Asset 1", group=g_pair3)
asset2_pair3_input = input.symbol("6B1!", "Asset 2", group=g_pair3)

g_pair4 = "Pair 4 Configuration"
asset1_pair4_input = input.symbol("BINANCE:BTCUSDT.P", "Asset 1", group=g_pair4)
asset2_pair4_input = input.symbol("BINANCE:ETHUSDT.P", "Asset 2", group=g_pair4)

// Display Settings
g_displaySettings = "Display Settings"
mode = input.string('All precision candles', 'Mode', options = ['PSP only', 'All precision candles'], group = g_displaySettings, tooltip = 'Select the mode for highlighting candles. \'All precision candles\' highlights all divergence candles, while \'PSP only\' highlights only Precision Swing Points with divergence.')
showDebug = input.bool(false, 'Show Debug Info', group = g_displaySettings, tooltip = 'Show debug information about current symbol and active pair')

// Open Divergence Settings
g_openDivergence = "Open Divergence Lines"
showOpenDivergence = input.bool(true, 'Show Open Divergence Lines', group = g_openDivergence, tooltip = 'Draw lines when opens show divergence trend between assets')
openDivergenceMode = input.string('Latest Only', 'Line Display Mode', options = ['All Lines', 'Latest Only'], group = g_openDivergence, tooltip = 'All Lines: Keep all divergence lines | Latest Only: Keep only the most recent lines')
maxLines = input.int(5, 'Max Lines (Latest Only)', minval = 1, maxval = 20, group = g_openDivergence, tooltip = 'Maximum number of lines to display in Latest Only mode')

// Divergence Display Settings
g_divergenceSettings = "Divergence Display Settings"
enableDivergences = input.bool(true, 'Enable Divergences', group = g_divergenceSettings, tooltip = 'Shows divergences on supported timeframes: W, D, H4, H1, M15, M5, M1')

// ==================== PSP FUNCTIONS ====================
// Function to extract symbol without exchange prefix
extractSymbol(fullSymbol) =>
    if str.contains(fullSymbol, ":")
        // Split at colon and take the part after it
        parts = str.split(fullSymbol, ":")
        array.size(parts) > 1 ? array.get(parts, 1) : fullSymbol
    else
        fullSymbol

// HTF positioning now uses xloc.bar_time for perfect temporal alignment

// Get the current chart symbol and check if it's part of any configured pair
currentSymbol = syminfo.ticker

// Extract clean symbols from inputs
asset1_pair1_clean = extractSymbol(asset1_pair1_input)
asset2_pair1_clean = extractSymbol(asset2_pair1_input)
asset1_pair2_clean = extractSymbol(asset1_pair2_input)
asset2_pair2_clean = extractSymbol(asset2_pair2_input)
asset1_pair3_clean = extractSymbol(asset1_pair3_input)
asset2_pair3_clean = extractSymbol(asset2_pair3_input)
asset1_pair4_clean = extractSymbol(asset1_pair4_input)
asset2_pair4_clean = extractSymbol(asset2_pair4_input)

// Check which pair the current symbol belongs to (if any)
isAsset1_Pair1 = currentSymbol == asset1_pair1_clean
isAsset2_Pair1 = currentSymbol == asset2_pair1_clean
isAsset1_Pair2 = currentSymbol == asset1_pair2_clean
isAsset2_Pair2 = currentSymbol == asset2_pair2_clean
isAsset1_Pair3 = currentSymbol == asset1_pair3_clean
isAsset2_Pair3 = currentSymbol == asset2_pair3_clean
isAsset1_Pair4 = currentSymbol == asset1_pair4_clean
isAsset2_Pair4 = currentSymbol == asset2_pair4_clean

// Determine which pair the current symbol belongs to
belongsToPair1 = isAsset1_Pair1 or isAsset2_Pair1
belongsToPair2 = isAsset1_Pair2 or isAsset2_Pair2
belongsToPair3 = isAsset1_Pair3 or isAsset2_Pair3
belongsToPair4 = isAsset1_Pair4 or isAsset2_Pair4
belongsToAnyPair = belongsToPair1 or belongsToPair2 or belongsToPair3 or belongsToPair4

// OPTIMIZED: Debug labels (only update when needed)
var label debugLabel = na
if showDebug and barstate.islast
    pairInfo = ""
    if belongsToPair1
        pairInfo := "Pair1: " + asset1_pair1_clean + "/" + asset2_pair1_clean
    else if belongsToPair2  
        pairInfo := "Pair2: " + asset1_pair2_clean + "/" + asset2_pair2_clean
    else if belongsToPair3
        pairInfo := "Pair3: " + asset1_pair3_clean + "/" + asset2_pair3_clean
    else if belongsToPair4
        pairInfo := "Pair4: " + asset1_pair4_clean + "/" + asset2_pair4_clean
    else
        pairInfo := "No pair found"

    debugText = "Current: " + currentSymbol + " | " + pairInfo
    if na(debugLabel)
        debugLabel := label.new(bar_index, high, debugText, style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
    else
        label.set_text(debugLabel, debugText)
        label.set_xy(debugLabel, bar_index, high)
else if not showDebug and not na(debugLabel)
    // Remove debug label if debug is disabled
    label.delete(debugLabel)
    debugLabel := na

// OPTIMIZED: Warning label (only update when needed)
var label infoLabel = na
if not belongsToAnyPair and barstate.islast
    if na(infoLabel)
        infoLabel := label.new(bar_index, high + ta.tr, "Symbol not part of configured pairs", 
                              style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)
    else
        label.set_xy(infoLabel, bar_index, high + ta.tr)

// Determine which assets to fetch data for based on current symbol
asset1 = if belongsToPair1
    asset1_pair1_input
else if belongsToPair2
    asset1_pair2_input
else if belongsToPair3
    asset1_pair3_input
else if belongsToPair4
    asset1_pair4_input
else
    na

asset2 = if belongsToPair1
    asset2_pair1_input
else if belongsToPair2
    asset2_pair2_input
else if belongsToPair3
    asset2_pair3_input
else if belongsToPair4
    asset2_pair4_input
else
    na

// Array to store divergence lines for Latest Only mode
var array<line> divergenceLines = array.new<line>()

// REFACTORED: Fixed timeframe logic - only 7 specific timeframes supported
// Check if current timeframe is supported
currentTF = timeframe.period
isSupported = currentTF == "1W" or currentTF == "1D" or currentTF == "240" or currentTF == "60" or currentTF == "15" or currentTF == "5" or currentTF == "1"

// DO NOT MODIFY belongsToAnyPair! It's needed for data fetching
// Create a separate variable for display control
canDisplay = isSupported and enableDivergences and belongsToAnyPair

// Determine what to display - FIX for W and D
showNormalDiv = false
showHTFDiv = false
htfToUse = ""

// Weekly and Daily ONLY show normal divergences, NO HTF
if currentTF == "1W" or currentTF == "1D"
    showNormalDiv := true
    showHTFDiv := false  // Explicitly no HTF

// H4, H1, M15 show BOTH normal and HTF
else if currentTF == "240"  // H4
    showNormalDiv := true
    showHTFDiv := true
    htfToUse := "W"
else if currentTF == "60"  // H1
    showNormalDiv := true
    showHTFDiv := true
    htfToUse := "D"
else if currentTF == "15"  // M15
    showNormalDiv := true
    showHTFDiv := true
    htfToUse := "240"

// M5 and M1 show ONLY HTF
else if currentTF == "5"  // M5
    showNormalDiv := false
    showHTFDiv := true
    htfToUse := "60"
else if currentTF == "1"  // M1
    showNormalDiv := false
    showHTFDiv := true
    htfToUse := "15"

// Processing flags - ensure they work for W and D
// Processing flags - use canDisplay instead of modifying belongsToAnyPair
processNormal = showNormalDiv and canDisplay
processHTF = showHTFDiv and canDisplay

// OPTIMIZED: Fetch data for the relevant pair only
asset1_open = belongsToAnyPair ? request.security(asset1, timeframe.period, open) : na
asset1_close = belongsToAnyPair ? request.security(asset1, timeframe.period, close) : na
asset1_close_before = belongsToAnyPair ? request.security(asset1, timeframe.period, close[2]) : na

asset1_high = belongsToAnyPair ? request.security(asset1, timeframe.period, high) : na
asset1_low = belongsToAnyPair ? request.security(asset1, timeframe.period, low) : na
asset1_high_1 = belongsToAnyPair ? request.security(asset1, timeframe.period, high[1]) : na
asset1_low_1 = belongsToAnyPair ? request.security(asset1, timeframe.period, low[1]) : na
asset1_high_2 = belongsToAnyPair ? request.security(asset1, timeframe.period, high[2]) : na
asset1_low_2 = belongsToAnyPair ? request.security(asset1, timeframe.period, low[2]) : na

asset2_open = belongsToAnyPair ? request.security(asset2, timeframe.period, open) : na
asset2_close = belongsToAnyPair ? request.security(asset2, timeframe.period, close) : na
asset2_close_before = belongsToAnyPair ? request.security(asset2, timeframe.period, close[2]) : na

asset2_high = belongsToAnyPair ? request.security(asset2, timeframe.period, high) : na
asset2_low = belongsToAnyPair ? request.security(asset2, timeframe.period, low) : na
asset2_high_1 = belongsToAnyPair ? request.security(asset2, timeframe.period, high[1]) : na
asset2_low_1 = belongsToAnyPair ? request.security(asset2, timeframe.period, low[1]) : na
asset2_high_2 = belongsToAnyPair ? request.security(asset2, timeframe.period, high[2]) : na
asset2_low_2 = belongsToAnyPair ? request.security(asset2, timeframe.period, low[2]) : na

// OPTIMIZED: Calculate swing points ONCE and reuse everywhere
asset1_SwingHigh = asset1_high_1 > asset1_high_2 and asset1_high_1 > asset1_high
asset1_SwingLow = asset1_low_1 < asset1_low_2 and asset1_low_1 < asset1_low
asset1_HasSwing = asset1_SwingHigh or asset1_SwingLow

asset2_SwingHigh = asset2_high_1 > asset2_high_2 and asset2_high_1 > asset2_high
asset2_SwingLow = asset2_low_1 < asset2_low_2 and asset2_low_1 < asset2_low
asset2_HasSwing = asset2_SwingHigh or asset2_SwingLow

// PSP condition: BOTH assets must have swing points simultaneously
bothAssetsHaveSwing = asset1_HasSwing and asset2_HasSwing

// OPTIMIZED: Only calculate normal divergence when needed (not on M5/M1)
bullish1 = false
bearish1 = false
bullish2 = false
bearish2 = false
divergence = false

if processNormal
    bullish1 := belongsToAnyPair and asset1_close > asset1_open
    bearish1 := belongsToAnyPair and asset1_close < asset1_open
    bullish2 := belongsToAnyPair and asset2_close > asset2_open
    bearish2 := belongsToAnyPair and asset2_close < asset2_open
    // Calculate divergence for current pair
    divergence := belongsToAnyPair and ((bullish1 and bearish2) or (bearish1 and bullish2))

// Overall highlight condition (current bar) - for colorization on ALL supported timeframes
current_highlight = canDisplay and barstate.isconfirmed and divergence

// Check if previous candle had divergence
had_divergence_prev = current_highlight[1]

// Set highlight for display
highlight = current_highlight

// Determine if current symbol is asset1 or asset2 of the active pair
isCurrentAsset1 = isAsset1_Pair1 or isAsset1_Pair2 or isAsset1_Pair3 or isAsset1_Pair4

// Check if previous candle should have divergence lines: now only requires divergence on [1], no swing requirement
should_draw_divergence_line = had_divergence_prev

// Calculate open trend divergence between candles surrounding the divergent one
open_divergence_exists = false
open_divergence_bullish = false
open_divergence_bearish = false

if processNormal and showOpenDivergence and should_draw_divergence_line
    // Trend from before divergence to after (current)
    // Asset 1 trend: from close[2] to open[0]
    asset1_trend_up = asset1_open > asset1_close_before
    asset1_trend_down = asset1_open < asset1_close_before
    
    // Asset 2 trend: from close[2] to open[0]
    asset2_trend_up = asset2_open > asset2_close_before
    asset2_trend_down = asset2_open < asset2_close_before
    
    // Divergence: opposite trends
    open_divergence_bullish := asset1_trend_up and asset2_trend_down
    open_divergence_bearish := asset1_trend_down and asset2_trend_up
    open_divergence_exists := open_divergence_bullish or open_divergence_bearish

// Draw lines between opens surrounding the divergent candle
if should_draw_divergence_line and open_divergence_exists and barstate.isconfirmed and showOpenDivergence
    // Line color based on HH/LL of the colored candle [1] vs previous [2]
    localLL = low[1] < low[2]
    localHH = high[1] > high[2]
    insideBar = high[1] <= high[2] and low[1] >= low[2]
    lineColor = insideBar ? color.white : localHH and not localLL ? color.red : localLL and not localHH ? color.green : color.red
    
    // Line connects close[2] to open[0], spanning over divergent candle[1]
    // Use LOCAL values of the currently displayed asset (not asset1/asset2 selection)
    prevPoint = close[2]   // Local close 2 bars ago of current asset
    openCurrent = open     // Local current open of current asset
    divergenceLine = line.new(x1 = bar_index[2], y1 = prevPoint, x2 = bar_index, y2 = openCurrent, color = lineColor, width = 2, style = line.style_solid)
    
    // Manage lines based on display mode
    if openDivergenceMode == 'Latest Only'
        array.push(divergenceLines, divergenceLine)
        if array.size(divergenceLines) > maxLines
            oldLine = array.shift(divergenceLines)
            line.delete(oldLine)
    // If 'All Lines' mode, just leave the line (no management needed)

// Track if a line was actually drawn on previous bar (only when line drawing is enabled)
line_was_drawn = showOpenDivergence and should_draw_divergence_line and open_divergence_exists and barstate.isconfirmed[1]

// ==================== HTF DIVERGENCE LOGIC ====================
// HTF Divergence calculation and line drawing - COMPLETELY REFACTORED
// Track if an HTF line is drawn on this bar (for coloring gate)
htf_line_drawn_now = false
if processHTF
    // Detect new HTF bar
    htf_new_bar = ta.change(time(htfToUse)) != 0
    
    // Get HTF asset data
    [htf_asset1_close, htf_asset1_open] = request.security(asset1, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close, htf_asset2_open] = request.security(asset2, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset1_close_prev, htf_asset1_open_prev] = request.security(asset1, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close_prev, htf_asset2_open_prev] = request.security(asset2, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    
    // Calculate HTF bullish/bearish for current and previous bars
    htf_bullish1 = htf_asset1_close > htf_asset1_open
    htf_bearish1 = htf_asset1_close < htf_asset1_open
    htf_bullish2 = htf_asset2_close > htf_asset2_open
    htf_bearish2 = htf_asset2_close < htf_asset2_open
    
    htf_bullish1_prev = htf_asset1_close_prev > htf_asset1_open_prev
    htf_bearish1_prev = htf_asset1_close_prev < htf_asset1_open_prev
    htf_bullish2_prev = htf_asset2_close_prev > htf_asset2_open_prev
    htf_bearish2_prev = htf_asset2_close_prev < htf_asset2_open_prev
    
    // Calculate HTF divergences
    htf_divergence_current = (htf_bullish1 and htf_bearish2) or (htf_bearish1 and htf_bullish2)
    htf_divergence_prev = (htf_bullish1_prev and htf_bearish2_prev) or (htf_bearish1_prev and htf_bullish2_prev)
    
    // HTF PSP detection for PSP only mode
    htf_is_psp = false
    if mode == 'PSP only'
        // Check HTF swing points on BOTH assets simultaneously
        // Asset1 HTF swing check
        [htf_asset1_high_2bars, htf_asset1_high_1bar, htf_asset1_high_current] = request.security(asset1, htfToUse, [high[2], high[1], high], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_asset1_low_2bars, htf_asset1_low_1bar, htf_asset1_low_current] = request.security(asset1, htfToUse, [low[2], low[1], low], barmerge.gaps_off, barmerge.lookahead_on)
        htf_asset1_SwingHigh = htf_asset1_high_1bar > htf_asset1_high_2bars and htf_asset1_high_1bar > htf_asset1_high_current
        htf_asset1_SwingLow = htf_asset1_low_1bar < htf_asset1_low_2bars and htf_asset1_low_1bar < htf_asset1_low_current
        htf_asset1_HasSwing = htf_asset1_SwingHigh or htf_asset1_SwingLow
        
        // Asset2 HTF swing check
        [htf_asset2_high_2bars, htf_asset2_high_1bar, htf_asset2_high_current] = request.security(asset2, htfToUse, [high[2], high[1], high], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_asset2_low_2bars, htf_asset2_low_1bar, htf_asset2_low_current] = request.security(asset2, htfToUse, [low[2], low[1], low], barmerge.gaps_off, barmerge.lookahead_on)
        htf_asset2_SwingHigh = htf_asset2_high_1bar > htf_asset2_high_2bars and htf_asset2_high_1bar > htf_asset2_high_current
        htf_asset2_SwingLow = htf_asset2_low_1bar < htf_asset2_low_2bars and htf_asset2_low_1bar < htf_asset2_low_current
        htf_asset2_HasSwing = htf_asset2_SwingHigh or htf_asset2_SwingLow
        
        // HTF PSP ONLY if BOTH assets have a swing point on HTF simultaneously
        htf_is_psp := (htf_asset1_HasSwing and htf_asset2_HasSwing) and htf_divergence_prev
    
    // Determine if we should draw HTF divergence line: now only requires HTF divergence on [1], no swing requirement
    htf_should_draw = htf_divergence_prev
    
    // Calculate HTF open trend divergence if we should draw
    if htf_should_draw and showOpenDivergence and htf_new_bar
        // Get HTF points for trend comparison (close[2] to open[0] on HTF)
        [htf_asset1_close_2bars, htf_asset1_open_current] = request.security(asset1, htfToUse, [close[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_asset2_close_2bars, htf_asset2_open_current] = request.security(asset2, htfToUse, [close[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        
        // HTF Asset trends: from close[2] to open[0] on HTF
        htf_asset1_trend_up = htf_asset1_open_current > htf_asset1_close_2bars
        htf_asset1_trend_down = htf_asset1_open_current < htf_asset1_close_2bars
        htf_asset2_trend_up = htf_asset2_open_current > htf_asset2_close_2bars
        htf_asset2_trend_down = htf_asset2_open_current < htf_asset2_close_2bars
        
        // HTF Open divergence: opposite trends
        htf_open_divergence_bullish = htf_asset1_trend_up and htf_asset2_trend_down
        htf_open_divergence_bearish = htf_asset1_trend_down and htf_asset2_trend_up
        htf_open_divergence_exists = htf_open_divergence_bullish or htf_open_divergence_bearish
        
        if htf_open_divergence_exists
            // HTF line color based on HH/LL of HTF colored candle [1] vs previous [2]
            [htf_low1, htf_low2, htf_high1, htf_high2] = request.security(syminfo.tickerid, htfToUse, [low[1], low[2], high[1], high[2]], barmerge.gaps_off, barmerge.lookahead_on)
            htfLL = htf_low1 < htf_low2
            htfHH = htf_high1 > htf_high2
            htf_insideBar = htf_high1 <= htf_high2 and htf_low1 >= htf_low2
            htf_color = htf_insideBar ? color.white : htfHH and not htfLL ? color.red : htfLL and not htfHH ? color.green : color.red
            
            // Get exact HTF timestamps and points for the CURRENT asset (not asset1/asset2 selection)
            // Start at the CLOSE of bar [2] (which is the OPEN time of bar [1]) and go to the OPEN of bar [0]
            [htf_time_2bars_ago, htf_time_current] = request.security(syminfo.tickerid, htfToUse, [time[1], time], barmerge.gaps_off, barmerge.lookahead_on)
            [htf_prevPoint, htf_openCurrent] = request.security(syminfo.tickerid, htfToUse, [close[2], open], barmerge.gaps_off, barmerge.lookahead_on)
            
            // Draw HTF line using exact timestamps for perfect temporal alignment
            htf_divergenceLine = line.new(x1 = htf_time_2bars_ago, y1 = htf_prevPoint, x2 = htf_time_current, y2 = htf_openCurrent, xloc = xloc.bar_time, color = htf_color, width = 2, style = line.style_solid)
            
            // Manage HTF lines (same system as normal lines)
            if openDivergenceMode == 'Latest Only'
                array.push(divergenceLines, htf_divergenceLine)
                if array.size(divergenceLines) > maxLines
                    oldLine = array.shift(divergenceLines)
                    line.delete(oldLine)
            // If 'All Lines' mode, just leave the line
            // Mark that an HTF line was drawn on this bar
            htf_line_drawn_now := true

// Determine overall bullish/bearish ONLY for normal divergences, NOT HTF
overallBullish = processNormal and (isCurrentAsset1 ? bullish1 : bullish2)
overallBearish = processNormal and (isCurrentAsset1 ? bearish1 : bearish2)

// OPTIMIZED: Detect swing points for PSP mode using pre-calculated values
isPsp = false
if mode == 'PSP only' and highlight[1]
    // OPTIMIZED: Use pre-calculated swing points
    isPsp := bothAssetsHaveSwing
else if mode == 'All precision candles'
    // For All precision candles mode, just use divergence
    isPsp := highlight[1]


// ==================== EXECUTE PSP LOGIC
// Define da conditions for direct PSP detection
isSwingHigh = high > high[1] and high > high[0]
isSwingLow = low < low[1] and low < low[0]
isPSP = (isSwingHigh or isSwingLow) and highlight

// Set bar color based on display mode
// On M5 and M1 (HTF-only), do NOT color bars
var color barColor = na
any_line_drawn = line_was_drawn or htf_line_drawn_now
if processNormal
    if mode == 'All precision candles'
        // Color ONLY if a line was drawn (divergence + open divergence)
        barColor := any_line_drawn ? (overallBullish[1] ? color.green : color.red) : na
    else if mode == 'PSP only'
        // Color like the other mode: only requires a line was drawn (no swing requirement)
        barColor := any_line_drawn ? (overallBullish[1] ? color.green : color.red) : na
else
    barColor := na

barcolor(barColor, offset = -1)// Apply bar color

// Plot shapes for 'All precision candles' mode - ONLY when line is drawn
plotshape(mode == 'All precision candles' and any_line_drawn and overallBullish[1], 
          style = shape.circle, 
          location = location.belowbar, 
          color = color.green, 
          size = size.auto, 
          offset = -1,
          title = 'Bullish PC',
          display = display.none)

plotshape(mode == 'All precision candles' and any_line_drawn and overallBearish[1], 
          style = shape.circle, 
          location = location.abovebar, 
          color = color.red, 
          size = size.auto, 
          offset = -1,
          title = 'Bearish PC',
          display = display.none)

// Plot shapes for 'PSP only' mode - ONLY when PSP AND line is drawn
plotshape(mode == 'PSP only' and isPsp and any_line_drawn and overallBullish[1], 
          style = shape.circle, 
          location = location.belowbar, 
          color = color.green, 
          size = size.auto, 
          offset = -1, 
          title = 'Bullish PSP',
          display = display.none)

plotshape(mode == 'PSP only' and isPsp and any_line_drawn and overallBearish[1], 
          style = shape.circle, 
          location = location.abovebar, 
          color = color.red, 
          size = size.auto, 
          offset = -1, 
          title = 'Bearish PSP',
          display = display.none)

// Clean up lines when open divergence feature is disabled
if not showOpenDivergence and array.size(divergenceLines) > 0
    for i = 0 to array.size(divergenceLines) - 1
        line.delete(array.get(divergenceLines, i))
    array.clear(divergenceLines)
