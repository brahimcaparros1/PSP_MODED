// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=6
indicator('QT Insights [Pro +]: PSP / PC [cephxs]', 'PSP [Pro +] | cephxs', overlay = true)

// ==================== PSP SETTINGS ====================
// Pair Configuration
g_pair1 = "Pair 1 Configuration"
asset1_pair1_input = input.symbol("ES1!", "Asset 1", group=g_pair1)
asset2_pair1_input = input.symbol("NQ1!", "Asset 2", group=g_pair1)

g_pair2 = "Pair 2 Configuration"
asset1_pair2_input = input.symbol("EURUSD", "Asset 1", group=g_pair2)
asset2_pair2_input = input.symbol("GBPUSD", "Asset 2", group=g_pair2)

g_pair3 = "Pair 3 Configuration"
asset1_pair3_input = input.symbol("6E1!", "Asset 1", group=g_pair3)
asset2_pair3_input = input.symbol("6B1!", "Asset 2", group=g_pair3)

g_pair4 = "Pair 4 Configuration"
asset1_pair4_input = input.symbol("BINANCE:BTCUSDT.P", "Asset 1", group=g_pair4)
asset2_pair4_input = input.symbol("BINANCE:ETHUSDT.P", "Asset 2", group=g_pair4)

// Display Settings
g_displaySettings = "Display Settings"
mode = input.string('All precision candles', 'Mode', options = ['PSP only', 'All precision candles'], group = g_displaySettings, tooltip = 'Select the mode for highlighting candles. \'All precision candles\' highlights all divergence candles, while \'PSP only\' highlights only Precision Swing Points with divergence.')
showDebug = input.bool(false, 'Show Debug Info', group = g_displaySettings, tooltip = 'Show debug information about current symbol and active pair')

// Open Divergence Settings
g_openDivergence = "Open Divergence Lines"
showOpenDivergence = input.bool(true, 'Show Open Divergence Lines', group = g_openDivergence, tooltip = 'Draw lines when opens show divergence trend between assets')
openDivergenceMode = input.string('Latest Only', 'Line Display Mode', options = ['All Lines', 'Latest Only'], group = g_openDivergence, tooltip = 'All Lines: Keep all divergence lines | Latest Only: Keep only the most recent lines')
maxLines = input.int(5, 'Max Lines (Latest Only)', minval = 1, maxval = 20, group = g_openDivergence, tooltip = 'Maximum number of lines to display in Latest Only mode')

// HTF Divergence Settings
g_htfDivergence = "HTF Divergence Settings"
showHTF = input.bool(true, 'Show HTF Divergences', group = g_htfDivergence, tooltip = 'Display Higher Timeframe divergences on specific target timeframes')
htf1 = input.timeframe("W", "HTF 1", group = g_htfDivergence, tooltip = 'Higher timeframe 1')
targetTF1 = input.timeframe("240", "Target TF 1", group = g_htfDivergence, tooltip = 'Target timeframe to display HTF 1 divergences')
htf2 = input.timeframe("D", "HTF 2", group = g_htfDivergence, tooltip = 'Higher timeframe 2')
targetTF2 = input.timeframe("60", "Target TF 2", group = g_htfDivergence, tooltip = 'Target timeframe to display HTF 2 divergences')
htf3 = input.timeframe("240", "HTF 3", group = g_htfDivergence, tooltip = 'Higher timeframe 3')
targetTF3 = input.timeframe("15", "Target TF 3", group = g_htfDivergence, tooltip = 'Target timeframe to display HTF 3 divergences')
htf4 = input.timeframe("60", "HTF 4", group = g_htfDivergence, tooltip = 'Higher timeframe 4')
targetTF4 = input.timeframe("5", "Target TF 4", group = g_htfDivergence, tooltip = 'Target timeframe to display HTF 4 divergences')
htf5 = input.timeframe("15", "HTF 5", group = g_htfDivergence, tooltip = 'Higher timeframe 5')
targetTF5 = input.timeframe("1", "Target TF 5", group = g_htfDivergence, tooltip = 'Target timeframe to display HTF 5 divergences')

// ==================== PSP FUNCTIONS ====================
// Function to extract symbol without exchange prefix
extractSymbol(fullSymbol) =>
    if str.contains(fullSymbol, ":")
        // Split at colon and take the part after it
        parts = str.split(fullSymbol, ":")
        array.size(parts) > 1 ? array.get(parts, 1) : fullSymbol
    else
        fullSymbol

// HTF positioning now uses xloc.bar_time for perfect temporal alignment

// Get the current chart symbol and check if it's part of any configured pair
currentSymbol = syminfo.ticker

// Extract clean symbols from inputs
asset1_pair1_clean = extractSymbol(asset1_pair1_input)
asset2_pair1_clean = extractSymbol(asset2_pair1_input)
asset1_pair2_clean = extractSymbol(asset1_pair2_input)
asset2_pair2_clean = extractSymbol(asset2_pair2_input)
asset1_pair3_clean = extractSymbol(asset1_pair3_input)
asset2_pair3_clean = extractSymbol(asset2_pair3_input)
asset1_pair4_clean = extractSymbol(asset1_pair4_input)
asset2_pair4_clean = extractSymbol(asset2_pair4_input)

// Check which pair the current symbol belongs to (if any)
isAsset1_Pair1 = currentSymbol == asset1_pair1_clean
isAsset2_Pair1 = currentSymbol == asset2_pair1_clean
isAsset1_Pair2 = currentSymbol == asset1_pair2_clean
isAsset2_Pair2 = currentSymbol == asset2_pair2_clean
isAsset1_Pair3 = currentSymbol == asset1_pair3_clean
isAsset2_Pair3 = currentSymbol == asset2_pair3_clean
isAsset1_Pair4 = currentSymbol == asset1_pair4_clean
isAsset2_Pair4 = currentSymbol == asset2_pair4_clean

// Determine which pair the current symbol belongs to
belongsToPair1 = isAsset1_Pair1 or isAsset2_Pair1
belongsToPair2 = isAsset1_Pair2 or isAsset2_Pair2
belongsToPair3 = isAsset1_Pair3 or isAsset2_Pair3
belongsToPair4 = isAsset1_Pair4 or isAsset2_Pair4
belongsToAnyPair = belongsToPair1 or belongsToPair2 or belongsToPair3 or belongsToPair4

// Debug labels (only show if enabled)
var label debugLabel = na
if showDebug
    pairInfo = ""
    if belongsToPair1
        pairInfo := "Pair1: " + asset1_pair1_clean + "/" + asset2_pair1_clean
    else if belongsToPair2  
        pairInfo := "Pair2: " + asset1_pair2_clean + "/" + asset2_pair2_clean
    else if belongsToPair3
        pairInfo := "Pair3: " + asset1_pair3_clean + "/" + asset2_pair3_clean
    else if belongsToPair4
        pairInfo := "Pair4: " + asset1_pair4_clean + "/" + asset2_pair4_clean
    else
        pairInfo := "No pair found"

    debugText = "Current: " + currentSymbol + " | " + pairInfo
    if na(debugLabel)
        debugLabel := label.new(bar_index, high, debugText, style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)
    else
        label.set_text(debugLabel, debugText)
        label.set_xy(debugLabel, bar_index, high)
else
    // Remove debug label if debug is disabled
    if not na(debugLabel)
        label.delete(debugLabel)
        debugLabel := na

// If current symbol doesn't belong to any pair, show warning
var label infoLabel = na
if not belongsToAnyPair
    if na(infoLabel)
        infoLabel := label.new(bar_index, high + ta.tr, "Symbol not part of configured pairs", 
                              style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)
    label.set_xy(infoLabel, bar_index, high + ta.tr)

// Determine which assets to fetch data for based on current symbol
asset1 = if belongsToPair1
    asset1_pair1_input
else if belongsToPair2
    asset1_pair2_input
else if belongsToPair3
    asset1_pair3_input
else if belongsToPair4
    asset1_pair4_input
else
    na

asset2 = if belongsToPair1
    asset2_pair1_input
else if belongsToPair2
    asset2_pair2_input
else if belongsToPair3
    asset2_pair3_input
else if belongsToPair4
    asset2_pair4_input
else
    na

// Array to store divergence lines for Latest Only mode
var array<line> divergenceLines = array.new<line>()

// HTF Detection Logic
htfToUse = ""
currentTF = timeframe.period
if showHTF
    if currentTF == targetTF1
        htfToUse := htf1
    else if currentTF == targetTF2
        htfToUse := htf2
    else if currentTF == targetTF3
        htfToUse := htf3
    else if currentTF == targetTF4
        htfToUse := htf4
    else if currentTF == targetTF5
        htfToUse := htf5

// Flag to check if we should process HTF data
processHTF = htfToUse != "" and belongsToAnyPair

// Fetch data for the relevant pair only
asset1_open = belongsToAnyPair ? request.security(asset1, timeframe.period, open) : na
asset1_close = belongsToAnyPair ? request.security(asset1, timeframe.period, close) : na
asset2_open = belongsToAnyPair ? request.security(asset2, timeframe.period, open) : na
asset2_close = belongsToAnyPair ? request.security(asset2, timeframe.period, close) : na

// Fetch opens for the candles surrounding a divergence
// Open 2 bars ago (before divergence candle)
asset1_open_before = belongsToAnyPair ? request.security(asset1, timeframe.period, open[2]) : na
asset2_open_before = belongsToAnyPair ? request.security(asset2, timeframe.period, open[2]) : na
// Current open will be used for the candle after divergence

// HTF Data Fetching - Now handled directly in HTF logic section

// Calculate divergence for the current pair only
bullish1 = belongsToAnyPair and asset1_close > asset1_open
bearish1 = belongsToAnyPair and asset1_close < asset1_open
bullish2 = belongsToAnyPair and asset2_close > asset2_open
bearish2 = belongsToAnyPair and asset2_close < asset2_open

// Calculate divergence using the exact logic from the working original
divergence = belongsToAnyPair and ((bullish1 and bearish2) or (bearish1 and bullish2))

// Overall highlight condition (current bar)
current_highlight = belongsToAnyPair and barstate.isconfirmed and divergence

// Check if previous candle had divergence
had_divergence_prev = current_highlight[1]

// Set highlight for display
highlight = current_highlight

// Determine if current symbol is asset1 or asset2 of the active pair
isCurrentAsset1 = isAsset1_Pair1 or isAsset1_Pair2 or isAsset1_Pair3 or isAsset1_Pair4

// Check if previous candle should have divergence lines based on current mode
should_draw_divergence_line = false
if mode == 'All precision candles'
    should_draw_divergence_line := had_divergence_prev
else if mode == 'PSP only'
    // Check if previous candle was a PSP (swing point with divergence)
    prevIsSwingHigh = high[1] > high[2] and high[1] > high[0]
    prevIsSwingLow = low[1] < low[2] and low[1] < low[0]
    prevIsPSP = (prevIsSwingHigh or prevIsSwingLow) and had_divergence_prev
    should_draw_divergence_line := prevIsPSP

// Calculate open trend divergence between candles surrounding the divergent one
open_divergence_exists = false
open_divergence_bullish = false
open_divergence_bearish = false

if belongsToAnyPair and showOpenDivergence and should_draw_divergence_line
    // Trend from before divergence to after (current)
    // Asset 1 trend: from open[2] to open[0]
    asset1_trend_up = asset1_open > asset1_open_before
    asset1_trend_down = asset1_open < asset1_open_before
    
    // Asset 2 trend: from open[2] to open[0]
    asset2_trend_up = asset2_open > asset2_open_before
    asset2_trend_down = asset2_open < asset2_open_before
    
    // Divergence: opposite trends
    open_divergence_bullish := asset1_trend_up and asset2_trend_down
    open_divergence_bearish := asset1_trend_down and asset2_trend_up
    open_divergence_exists := open_divergence_bullish or open_divergence_bearish

// Draw lines between opens surrounding the divergent candle
if should_draw_divergence_line and open_divergence_exists and barstate.isconfirmed and showOpenDivergence
    // Line color based on divergence type
    lineColor = open_divergence_bullish ? color.rgb(0, 255, 0, 0) : color.rgb(255, 0, 0, 0)
    
    // Line connects open[2] to open[0], spanning over divergent candle[1]
    // Use correct opens based on current asset
    openBefore = isCurrentAsset1 ? asset1_open_before : asset2_open_before
    openCurrent = isCurrentAsset1 ? asset1_open : asset2_open
    divergenceLine = line.new(x1 = bar_index[2], y1 = openBefore, x2 = bar_index, y2 = openCurrent, color = lineColor, width = 2, style = line.style_solid)
    
    // Manage lines based on display mode
    if openDivergenceMode == 'Latest Only'
        array.push(divergenceLines, divergenceLine)
        if array.size(divergenceLines) > maxLines
            oldLine = array.shift(divergenceLines)
            line.delete(oldLine)
    // If 'All Lines' mode, just leave the line (no management needed)

// ==================== HTF DIVERGENCE LOGIC ====================
// HTF Divergence calculation and line drawing - COMPLETELY REFACTORED
if processHTF
    // Detect new HTF bar
    htf_new_bar = ta.change(time(htfToUse)) != 0
    
    // Get HTF asset data
    [htf_asset1_close, htf_asset1_open] = request.security(asset1, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close, htf_asset2_open] = request.security(asset2, htfToUse, [close, open], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset1_close_prev, htf_asset1_open_prev] = request.security(asset1, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    [htf_asset2_close_prev, htf_asset2_open_prev] = request.security(asset2, htfToUse, [close[1], open[1]], barmerge.gaps_off, barmerge.lookahead_on)
    
    // Calculate HTF bullish/bearish for current and previous bars
    htf_bullish1 = htf_asset1_close > htf_asset1_open
    htf_bearish1 = htf_asset1_close < htf_asset1_open
    htf_bullish2 = htf_asset2_close > htf_asset2_open
    htf_bearish2 = htf_asset2_close < htf_asset2_open
    
    htf_bullish1_prev = htf_asset1_close_prev > htf_asset1_open_prev
    htf_bearish1_prev = htf_asset1_close_prev < htf_asset1_open_prev
    htf_bullish2_prev = htf_asset2_close_prev > htf_asset2_open_prev
    htf_bearish2_prev = htf_asset2_close_prev < htf_asset2_open_prev
    
    // Calculate HTF divergences
    htf_divergence_current = (htf_bullish1 and htf_bearish2) or (htf_bearish1 and htf_bullish2)
    htf_divergence_prev = (htf_bullish1_prev and htf_bearish2_prev) or (htf_bearish1_prev and htf_bullish2_prev)
    
    // HTF PSP detection for PSP only mode
    htf_is_psp = false
    if mode == 'PSP only'
        // Get HTF high/low data for PSP detection (need [2], [1], [0] like normal logic)
        [htf_high_2bars, htf_high_1bar, htf_high_current] = request.security(syminfo.tickerid, htfToUse, [high[2], high[1], high], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_low_2bars, htf_low_1bar, htf_low_current] = request.security(syminfo.tickerid, htfToUse, [low[2], low[1], low], barmerge.gaps_off, barmerge.lookahead_on)
        
        // HTF PSP logic: check if bar[1] is a swing point (same as normal logic)
        htf_prevIsSwingHigh = htf_high_1bar > htf_high_2bars and htf_high_1bar > htf_high_current
        htf_prevIsSwingLow = htf_low_1bar < htf_low_2bars and htf_low_1bar < htf_low_current
        htf_is_psp := (htf_prevIsSwingHigh or htf_prevIsSwingLow) and htf_divergence_prev
    
    // Determine if we should draw HTF divergence line based on mode
    htf_should_draw = false
    if mode == 'All precision candles'
        htf_should_draw := htf_divergence_prev
    else if mode == 'PSP only'
        htf_should_draw := htf_is_psp
    
    // Calculate HTF open trend divergence if we should draw
    if htf_should_draw and showOpenDivergence and htf_new_bar
        // Get HTF opens for line drawing (open[2] to open[0] on HTF)
        [htf_asset1_open_2bars, htf_asset1_open_current] = request.security(asset1, htfToUse, [open[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        [htf_asset2_open_2bars, htf_asset2_open_current] = request.security(asset2, htfToUse, [open[2], open], barmerge.gaps_off, barmerge.lookahead_on)
        
        // HTF Asset trends: from open[2] to open[0] on HTF
        htf_asset1_trend_up = htf_asset1_open_current > htf_asset1_open_2bars
        htf_asset1_trend_down = htf_asset1_open_current < htf_asset1_open_2bars
        htf_asset2_trend_up = htf_asset2_open_current > htf_asset2_open_2bars
        htf_asset2_trend_down = htf_asset2_open_current < htf_asset2_open_2bars
        
        // HTF Open divergence: opposite trends
        htf_open_divergence_bullish = htf_asset1_trend_up and htf_asset2_trend_down
        htf_open_divergence_bearish = htf_asset1_trend_down and htf_asset2_trend_up
        htf_open_divergence_exists = htf_open_divergence_bullish or htf_open_divergence_bearish
        
        if htf_open_divergence_exists
            // HTF Line color (same as normal lines)
            htf_lineColor = htf_open_divergence_bullish ? color.rgb(0, 255, 0, 0) : color.rgb(255, 0, 0, 0)
            
            // Get exact HTF timestamps for perfect alignment
            [htf_time_2bars_ago, htf_time_current] = request.security(syminfo.tickerid, htfToUse, [time[2], time], barmerge.gaps_off, barmerge.lookahead_on)
            
            // Use correct opens based on current asset
            htf_openBefore = isCurrentAsset1 ? htf_asset1_open_2bars : htf_asset2_open_2bars
            htf_openCurrent = isCurrentAsset1 ? htf_asset1_open_current : htf_asset2_open_current
            
            // Draw HTF line using exact timestamps for perfect temporal alignment
            htf_divergenceLine = line.new(x1 = htf_time_2bars_ago, y1 = htf_openBefore, x2 = htf_time_current, y2 = htf_openCurrent, xloc = xloc.bar_time, color = htf_lineColor, width = 2, style = line.style_solid)
            
            // Manage HTF lines (same system as normal lines)
            if openDivergenceMode == 'Latest Only'
                array.push(divergenceLines, htf_divergenceLine)
                if array.size(divergenceLines) > maxLines
                    oldLine = array.shift(divergenceLines)
                    line.delete(oldLine)
            // If 'All Lines' mode, just leave the line

// Determine overall bullish/bearish direction based on the current chart asset
overallBullish = belongsToAnyPair and (isCurrentAsset1 ? bullish1 : bullish2)
overallBearish = belongsToAnyPair and (isCurrentAsset1 ? bearish1 : bearish2)

// Detect swing points for PSP mode
pivothigh = ta.pivothigh(high, 1, 1)
pivotlow = ta.pivotlow(low, 1, 1)
is_swing_high = not na(pivothigh)
is_swing_low = not na(pivotlow)
isPsp = (is_swing_high or is_swing_low) and highlight[1] // Check divergence on swing point candle


// ==================== EXECUTE PSP LOGIC
// Define da conditions for direct PSP detection
isSwingHigh = high > high[1] and high > high[0]
isSwingLow = low < low[1] and low < low[0]
isPSP = (isSwingHigh or isSwingLow) and highlight

// Set bar color based on display mode and PSP mode
var color barColor = na
if mode == 'All precision candles'
    barColor := highlight ? (overallBullish ? color.rgb(103, 143, 109) : color.rgb(219, 87, 85)) : na
else if mode != 'All precision candles'
    barColor := isPsp ? (overallBullish[1] ? color.rgb(117, 173, 120) : color.rgb(182, 105, 107)) : na

barcolor(barColor, offset = -1)// Apply bar color

// Plot shapes for 'All precision candles' mode
plotshape(mode == 'All precision candles' and highlight and overallBullish, 
          style = shape.circle, 
          location = location.belowbar, 
          color = color.rgb(103, 143, 109), 
          size = size.auto, 
          title = 'Bullish PC')

plotshape(mode == 'All precision candles' and highlight and overallBearish, 
          style = shape.circle, 
          location = location.abovebar, 
          color = color.rgb(219, 87, 85), 
          size = size.auto, 
          title = 'Bearish PC')

// Plot shapes for 'PSP only' mode
plotshape(mode == 'PSP only' and isPsp and overallBullish[1], 
          style = shape.circle, 
          location = location.belowbar, 
          color = color.rgb(117, 173, 120), 
          size = size.auto, 
          offset = -1, 
          title = 'Bullish PSP')

plotshape(mode == 'PSP only' and isPsp and overallBearish[1], 
          style = shape.circle, 
          location = location.abovebar, 
          color = color.rgb(182, 105, 107), 
          size = size.auto, 
          offset = -1, 
          title = 'Bearish PSP')

// Clean up lines when open divergence feature is disabled
if not showOpenDivergence and array.size(divergenceLines) > 0
    for i = 0 to array.size(divergenceLines) - 1
        line.delete(array.get(divergenceLines, i))
    array.clear(divergenceLines)